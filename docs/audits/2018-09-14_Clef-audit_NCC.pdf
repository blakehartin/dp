Ethereum Clef Review

Ethereum Foundation

September 14, 2018 – Version 1.0

Prepared for

Martin Swende

Prepared by

David Wong
Eric Schorn
Executive Summary                                             via accounts/usbwallet. While a full review of
                                                              these packages was not in scope, the consultants
In the start of September 2018, the Ethereum Foun-            have partially reviewed them when relevant to the Clef
dation contracted NCC Group to perform a review of            application.
the Clef command-line interface. The Clef CLI is a self-
contained account management tool that can also be            BigNumber.js. Javascript rules written for Clef can make
used as a “signing server” to auto-approve transactions       use of this extra dependency for handling big numbers.
and other available methods of an API exposed through         This library is a single file of less than 3000 lines of code
various interfaces. One consultant was tasked to look         and was not audited as part of this engagement.
for usability and security issues with the tool and its API.
One extra consultant was added to the project at no ex-       Otto. Otto is a Javascript interpreter written in Go used
tra cost to the Ethereum Foundation. A discord channel        by Clef to execute the rules written by users. It is quite
was used to communicate with the development team.            an important package with around 40,000 lines of code.
Some medium-risk issues were discovered while a few           Note that this package is also used in other parts of go-
observations and recommendations were written up.             ethereum.
No major issues were found.
                                                              GUI-based Clef. Clef can be used in conjunction with a
Scope                                                         graphical interface. The consultants did not spend time
                                                              looking at these applications.
Commit 70cfedc9d7bd64f1f112eb2099a5c36266863f4
0 of Clef was audited, the scope included the following       Key Findings
items:
                                                              While no major findings were found, a few medium-risk
Clef. The Ethereum Foundation has developed a self-           findings were discovered:
contained tool for account management. It can be used
to create accounts, list them, sign transactions, sign        • Lack of Complexity Check for Passphrases. As it
arbitrary data and recover public keys from signatures.         is, Clef does not enforce any minimum-length on
It can be used as a simple command-line interface (CLI)         passphrases used to protect private keys. Users are
or with a graphical user interface (GUI). Requests are          incentivized not to use a passphrase (length 0) or to
made through an API exposed via an IPC or a JSON-RPC            use a weak passphrase (length < 8).
interface. Clef can also be used with different types of
“backends”, from simple file system wallets to hardware       • Denial of Services of Clef’s API. Malformed requests
wallets like the Trezor1 and the Nano Ledger.2                  can crash the application, which could be of temporary
                                                                damage to long-lived automated configurations of
Rules. Clef supports automation of requests handling,           Clef.
allowing users to develop Javascript functions that will
approve or reject requests to the API based on time,          • Encryption of Clef Backup is Insufficient. Clef uses
the Clef state and the request being made. This allows          a master secret to encrypt several important piece
Clef to run without user-interaction (although it will be       of information including passphrases that can unlock
required as a fallback if the functions written fail to         Ethereum wallets. This master secret is then stored in
correctly approve or reject requests).                          clear on the device running Clef, accessible to users
                                                                with enough permissions, to physical breaches on
The following items were not included in scope:                 devices with no disk encryption or to accidental copies
                                                                of the file to other locations.
Crypto. Clef relies on a couple of cryptographic
primitives which are not part of the standard go library:     Strategic Recommendations
keccak256 (a variant of SHA-3) and secp256k1 (for the
ECDSA signature algorithm and recovering public keys          NCC Group recommends that the Ethereum Foundation
out of such signatures).                                      takes the following points into consideration in order to
                                                              increase the security stance of Clef:
Accounts. Clef relies heavily on the accounts package
of go-ethereum for parsing a transaction’s call data via      • Documentation. Thoroughly document the threat
accounts/abi, for managing accounts via accounts/               model of Clef, and list what users need to protect
keystore and for compatibility with hardware wallets            against in high-stake situations. Ensure that all
                                                                examples of rules are up-to-date and secure by default
1https://trezor.io/
2https://www.ledger.com/                                                        Ethereum Foundation / NCC Group Confidential

2 | Ethereum Clef Review
  so that they can be copy/pasted by users.
• External Dependencies. Clef makes use of large

  dependencies that could impact the well-functioning
  of the program. Otto3 is used as a Javascript inter-
  preter to run rules written by users; bignumber.js4 is
  used as a Javascript library to handle large numbers.
  The Ethereum Foundation should ensure that these
  dependencies are up-to-date and have been audited.
• Go-Ethereum Dependencies. The accounts pack-
  age is a large piece of go-ethereum that Clef lever-
  ages. It handles on-disk encryption and storage of
  wallets, communication with hardware wallets, and
  contracts’ ABI logic. The crypto package is used
  by Clef to handle public-key cryptography logic and
  hashing. The Ethereum Foundation should consider
  auditing these parts as they are central pieces of the
  tool.

3https://github.com/robertkrimen/otto                     Ethereum Foundation / NCC Group Confidential
4https://github.com/MikeMcl/bignumber.js/

3 | Ethereum Clef Review
Dashboard

Target Metadata                                    Engagement Data

Name                  Clef                         Type             Code Review

Type                  Command-Line Interface       Method           Code-assisted

Platforms             Go                           Dates            2018-09-03 to 2018-09-14

Environment           Local Instance               Consultants      1

                                                   Level of effort  10 person-days

Targets

Clef                  github.com/holiman/go-ethereum/blob/clefchanges_2/cmd/clef

Finding Breakdown

Critical Risk issues        0

High Risk issues            0

Medium Risk issues          4

Low Risk issues             8

Informational issues        1

Total issues                13

Category Breakdown

Authentication              2

Configuration               2

Cryptography                3

Data Validation             4

Denial of Service           1

Patching                    1

Component Breakdown

keystore                    1

Key                High     Medium            Low          Informational
                                                                      Ethereum Foundation / NCC Group Confidential
Critical

4 | Ethereum Clef Review
Table of Findings

For each finding, NCC Group uses a composite risk score that takes into account the severity of the risk, application’s
exposure and user population, technical difficulty of exploitation, and other factors. For an explanation of NCC Group’s
risk rating and finding categorization, see Appendix A on page 24.

Title                                                            ID Risk
Encryption of Clef Backup is Insufficient                        002 Medium
Lack of Password Strength Check                                  005 Medium
Validation Of Transaction Data Field Fails Open                  007 Medium
Denial of Service Through Incorrect Method Selector              010 Medium
Incorrect File Permissions For secrets.dat                       001 Low
Encrypted Values From Key-Value Encrypted Storage Are Swappable  003 Low
Lack of Guidance on Exposed Clef API                             004 Low
ECRecover Does Not Authenticate The Recovered Public Key         009 Low
Outdated Dependencies                                            011 Low
Rules Dangerously Rely On Time And State                         012 Low
Denial of Service Through Malformed Import Key                   013 Low
Encrypted KeyStore Integrity Check Is Incomplete                 014 Low
UI Mixes Extraneous and Approval-Specific Data                   006 Informational

5 | Ethereum Clef Review                                         Ethereum Foundation / NCC Group Confidential
Finding Details

Finding Encryption of Clef Backup is Insufficient

Risk Medium Impact: High, Exploitability: Low

Identifier NCC-EF-Clef-002

Category Authentication

Location • cmd/clef/main.go:initializeSecrets()

Impact An attacker able to compromise a user’s device has full access to Clef’s encrypted back up.

Description               Clef stores a number of files on disk, such as credentials.json containing account cre-
                          dentials and config.json containing the JavaScript rule-file hashes, in order to be able to
                          recover from a restart. These files are encrypted by keys derived from a single seed which is
                          stored in cleartext on disk in the secrets.dat file.

                          An attacker able to access secrets.dat and credentials.json would have full and un-
                          restricted access to accounts and their value. Because of this, a device not protected with
                          disk encryption that gets physically breached would leak all information stored under Clef’s
                          encrypted backup. A running device that gets remotely breached would also compromise
                          a dormant Clef application, irrespective of disk encryption. Furthermore, an accidental non-
                          encrypted copy or backup of these files to a different location could compromise a user’s
                          accounts.

Recommendation            Enforce usage of a passphrase to start the Clef command-line interface. Leverage the same
                          passphrase mechanisms as in go-ethereum/accounts/keystore to protect the secrets.dat
                          file.

6 | Ethereum Clef Review                           Ethereum Foundation / NCC Group Confidential
Finding Lack of Password Strength Check

Risk Medium Impact: Medium, Exploitability: Low

Identifier NCC-EF-Clef-005

Category Authentication

Location • signer/core/api.go:New()

Impact                    An attacker may guess insecure user passwords or brute-force weak user passwords in the
                          event of a breach. This would allow the attacker to retrieve private keys of the user’s Ethereum
                          accounts.

Description               The Clef CLI can be used to create and manage Ethereum externally owned accounts. The
                          account creation process can be started by sending the following RPC request to Clef (if run
                          with the --rpc option):

                          curl -H "Content-Type: application/json" -X POST --data '{"jsonrpc":"2.0","metho
                                d":"account_new","params":["test"],"id":67}' localhost:8550

                          The user running the Clef process is then prompted to enter a password which is used to
                          protect the account’s private key. At this point the user can enter an arbitrary-length pass-
                          word (empty passwords are also accepted). This would facilitate recovery of the accounts’s
                          private keys to attackers physically or remotely breaching the device where Clef is installed.

Recommendation            Enforce a minimum password length. The NIST organization has published documents5
                          about the topic, recommending to set a minimum-length of 8 characters for such passwords.
                          Additionally, check for known bad passwords. Various lists of known bad passwords like the
                          NBP6 exist.

Client Response           Clef now enforce passwords of 10 characters at a minimum: github.com/holiman/go-ethere
                          um/commit/193f7049719a2da9018027853d0c2237cdad602b

                          5https://pages.nist.gov/800-63-3/
                          6NIST Bad Passwords:https://cry.github.io/nbp/

7 | Ethereum Clef Review                         Ethereum Foundation / NCC Group Confidential
Finding Validation Of Transaction Data Field Fails Open

Risk Medium Impact: High, Exploitability: Low

Identifier NCC-EF-Clef-007

Category Data Validation

Location • signer/core/{abihelper,validation}.go

Impact A maliciously crafted data field could allow an attacker to deceive the signer’s intent.

Description               When receiving a request to sign a transaction, Clef first attempts to perform a few validation
                          checks before passing the request to the user. If a special argument is passed to the request
                          (a method’s signature) the program also attempts to match it against the data field. In that
                          case, the data field must be composed of a 4-byte identifier for the function called (which is
                          the hash of the method’s signature truncated to 4 bytes) and a multiple of 32 bytes:

                          func parseCallData(calldata []byte, abidata string) (*decodedCallData, error) {
                                       if len(calldata) < 4 {

                                                    return nil, fmt.Errorf("Invalid ABI-data, incomplete method sign
                                ature of (%d bytes)", len(calldata))

                                       }
                                       sigdata, argdata := calldata[:4], calldata[4:]
                                       if len(argdata)%32 != 0 {

                                                    return nil, fmt.Errorf("Not ABI-encoded data; length should be a
                                multiple of 32 (was %d)", len(argdata))

                                       }

                          This check is not enforced if no method signature is passed as argument in the request to
                          Clef. This is because method signatures are not an Ethereum Virtual Machine feature but a
                          Solidity-specific feature. If the check fails, Clef still end up passing the request to the user
                          with a warning:

                           info, err = testSelector(*methodSelector, data)
                           if err != nil {

                                        msgs.warn(fmt.Sprintf("Tx contains data, but provided ABI signature coul
                                 d not be matched: %v", err))
                           }

                          Since users of the Clef CLI are not expected to always pass a method signature, or to un-
                          derstand the warning associated to a failed ABI signature check, the behavior of Clef might
                          incentivize users to click through them (this is called alert fatigue). Because of this, malicious
                          DAPPs could attempt short address attacks7 or other yet unknown attacks where transac-
                          tions’ calldata is malformed.

Recommendation            In the cases where a method signature is passed, the data field format should always be
                          enforced to be of length 4 + k × 32 with k ≥ 0. If this is not the case, Clef should not pass
                          the request to the end user. In the cases where a method signature is not passed and the
                          data field is not empty, its format should still be checked against the previously discussed
                          encoding. If it does not validate, Clef should reject the transaction (unless configured to
                          lighten its validations or with a whitelist of relaxed contract addresses). Alternatively, if non-
                          standard transactions need default support, the user should be warned that the transaction
                          data field is not standard.

                          7https://www.dasp.co/#item-9

8 | Ethereum Clef Review                          Ethereum Foundation / NCC Group Confidential
Client Response           Validations that return warnings are now rejecting transactions by default, a new “advanced”
                          mode was added to bypass this behavior: github.com/holiman/go-ethereum/commit/193f7
                          049719a2da9018027853d0c2237cdad602b

9 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Finding Denial of Service Through Incorrect Method Selector

Risk Medium Impact: Low, Exploitability: Low

Identifier NCC-EF-Clef-010

Category Data Validation

Location • signer/core/abihelper.go:parseCallData()
               • accounts/abi/abi.go:JSON()

Impact An attacker with access to Clef’s API can crash the application.

Description                In some use-cases Clef is used to run continuously, accepting requests and accepting them
                           based on rules written by the user. In such cases, a crash could prevent legitimate transac-
                           tions to be processed until the application is restarted.

                           The account_signTransaction API handles transaction signing requests. In order to pro-
                           vide useful information to the user, the endpoint making the request can provide the method
                           signature of the function being called (in cases where the transaction would result in a con-
                           tract execution). If this method signature is malformed, Clef crashes. Currently a single regex
                           is used to validate this user input:

                           // MethodSelectorToAbi converts a method selector into an ABI struct. The return
                                 ed data is a valid json string

                           // which can be consumed by the standard abi package.
                           func MethodSelectorToAbi(selector string) ([]byte, error) {

                                        re := regexp.MustCompile(`^([^\)]+)\(([a-z0-9,\[\]]*)\)`)
                                        groups := re.FindStringSubmatch(selector)

                           While the regex is expected to validate typical function signatures:
                            functionName(uint256, string, address)

                           It is too liberal, using a blacklist instead of a whitelist. This overly-accepting policy permits the
                           following kind of user inputs:

                           • functionName can be anything but \ and )
                           • arguments can be alphanumeric strings and contain [ and ] but do not have to enforce

                             syntactically correct brackets
                           • argument list can end and start with ,
                           • the end of the function signature can contain anything

                           This mean that the following function signatures are valid according to the current checks:

                            call(a,a],bbbb932[,)
                            #@#((@$!(uint256) anything

Reproduction Steps Run the following in the terminal with a Clef process exposing an RPC interface on local-
                              host:8550 and observe that the Clef application crashes.

10 | Ethereum Clef Review                            Ethereum Foundation / NCC Group Confidential
                                curl -i -H "Content-Type: application/json" -X POST --data '{"jsonrpc":"2.0","me
                                      thod":"account_signTransaction","params":[{"from":"0x82A2A876D39022B3019932D
                                      30Cd9c97ad5616813","gas":"0x333","gasPrice":"0x123","nonce":"0x0","to":"0x07
                                      a565b7ed7d7a678680a4c162885bedbb695fe0", "value":"0x10", "data":"0x4401a6e40
                                      000000000000000000000000000000000000000000000000000000000000012"}, "func(uin
                                      t256,uint256,[]uint256)"],"id":67}' http://localhost:8550/

                            The following method signatures all make the application crash:

                                func(uint256,uint256,[]uint256)
                                func(uint256,uint256,uint256,)
                                func(,uint256,uint256,uint256)

Recommendation In order to address this issue:

                            1. Investigate the JSON decoder of the abi package to find the root cause of the error.
                            2. Further validate the received method signature before attempting to operate on it.

  Client Response A Pull Request was introduced to fix the bug: github.com/ethereum/go-ethereum/pull/17653

11 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Finding Incorrect File Permissions For secrets.dat

Risk Low Impact: High, Exploitability: Low

Identifier NCC-EF-Clef-001

Category Configuration

Location • Permissions set in initializeSecrets() on line 228 of cmd/clef/main.go
               • Permissions checked in checkFile() on line 550 of cmd/clef/main.go

Impact The master seed may be deleted or overwritten resulting in the loss of access to account
             credentials and JavaScript rule-file hashes.

Description                The secrets.dat file contains the master seed, which is required to be able to store and
                           retrieve account credentials and JavaScript rule-file hashes. In practice, this central file is
                           written once, contains the critical root secret stored in the clear, and must be maximally
                           protected.

                           Master seed generation and storage is the primary purpose of the initializeSecrets()
                           function in cmd/clef/main.go. The seed is written to disk on line 228 with file permissions
                           set to 700. This corresponds to full permissions for the owner – read, write and execute. As
                           a result, the owner may easily delete or overwrite this file resulting in loss of access to the
                           storage mentioned above. In principle, the owner may also attempt to execute this file.

                           The primary purpose of the checkFile() function in cmd/clef/main.go is to check the file
                           permissions of the secrets.dat file. On line 550, the file permissions are read, logically
                           ‘ANDed’ with 077 and compared to 0 - with any result other than 0 being an error. This is
                           consistent with verifying the storage permissions set in initializeSecrets() as described
                           above.

                           For secrets.dat, the write permission should not be set by default and the execution per-
                           mission is also inappropriate. The handling of the secrets.dat file is analogous to handling
                           SSH keys.8

                           Separately, note that the file permissions for the account credentials stored in credentials.json
                           and the JavaScript rule-file hashes stored in config.json are currently set to 600 by the w
                           riteEncryptedStorage function in signer/storageaes_gcm_storage.go. This is consid-
                           ered appropriate due to the read/write nature of the key-value storage and the fact that the
                           contents are always encrypted by the root secret.

Recommendation             The file permissions for secrets.dat should be set to 400 (instead of 700) in initializeS-
                           ecrets(). The file permissions for secrets.dat should be ‘ANDed’ with 377 (instead of 077)
                           in checkFile() to maintain consistency.

                           8https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/TroubleshootingInstancesConnecting.html#troublesho
                           ot-unprotected-key

12 | Ethereum Clef Review                   Ethereum Foundation / NCC Group Confidential
Finding Encrypted Values From Key-Value Encrypted Storage Are Swappable

Risk Low Impact: Low, Exploitability: Low

Identifier NCC-EF-Clef-003

Category Cryptography

Location • signer/storage/aes_gcm_storage.go

Impact                     An attacker with permissions to the encrypted backup files of Clef could swap around the
                           encrypted passwords for the user’s keystores. This could allow weak attacks (like confirming
                           if different keys are protected by the same passphrase), or yet unknown complex attacks
                           depending on the rules in use by Clef.

Description The Clef command-line interface stores the following data on disk, in an encrypted form, in
                   order to facilitate recovery after restarts of the application:

                           • passwords for keystores (used by rule engine)
                           • storage for javascript rules
                           • hash of rule-file

                           The storage and encryption is done via a key-value store where only the values are encrypted
                           via AES-GCM:

                            // Put stores a value by key. 0-length keys results in no-op
                            func (s *AESEncryptedStorage) Put(key, value string) {

                                         // ...
                                         ciphertext, iv, err := encrypt(s.key, []byte(value))
                                         // ...
                                         encrypted := storedCredential{Iv: iv, CipherText: ciphertext}
                                         data[key] = encrypted
                                         // ...
                            }

                           The key-values are then encoded in the JSON format and saved on disk as can be seen in the
                           following example:

                            {
                               "key1": {
                                  "iv": "IQZYrnH0YjbcLmBD",
                                  "c": "oP2S7Li+YYPt2vQcfDgUlc/QaIk="
                               },
                               "key2": {
                                  "iv": "OVilp+zm+OvgH7Vm",
                                  "c": "DP7kmTyJR89nTMb1mfRPokIYRpg="
                               }

                            }

                           An attacker with the correct permissions to these files can tamper them to swap around the
                           values of key1 and key2 such that when key1 is retrieved from storage, the value associated
                           to key2 is obtained.

Recommendation Include the key part of the key-value in the additionalData field of the Seal() and Open()
                            functions. See the cipher package9 for more information.

Client Response the key part of the key-value was added as additional data to AES-GCM: github.com/holiman

                                 9https://golang.org/pkg/crypto/cipher/

13 | Ethereum Clef Review                                                   Ethereum Foundation / NCC Group Confidential
                           /go-ethereum/commit/913f77ca8c5c08749b9d668adeb1ab02bbc30663

14 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Finding Lack of Guidance on Exposed Clef API

Risk Low Impact: Low, Exploitability: Undetermined

Identifier NCC-EF-Clef-004

Category Denial of Service

Location • cmd/clef/main.go

Impact An attacker with access to the Clef API can quickly spam the interface and render it useless,
             forcing the user to restart the application in order to process legitimate requests.

Description                An attacker who has access to the public API of Clef (through an RPC interface exposed to
                           the internet for example) can quickly spam the process with requests that will need to be
                           manually handled, in order, by the end user.

                           If such an attack is performed, the end user will be incapable of going on with normal oper-
                           ations without restarting the process.

                           In addition, requests done over Ethereum’s RPC protocol are not encrypted. While most of
                           the API requests and responses might eventually be published on the Ethereum network, the
                           “account_sign” method (aimed at signing arbitrary data for different purposes) might require
                           secrecy.

Reproduction Steps Run the following bash script with a Clef process exposing an RPC interface on localhost:8550
                               and observe that the Clef user now has to accept requests one by one.

                           for i in {1..100}

                           do curl --no-buffer -H "Content-Type: application/json" -X POST --data '{"jsonrp
                                 c":"2.0","method":"account_new","params":["test"],"id":67}' localhost:8550 &

                           done
                           kill $(jobs -p)

Recommendation Add ways to encrypt the connection (via TLS) and to authenticate clients to the Clef API.

                            Alternatively, delegate these tasks to a lower-layer protocol or a fronting proxy, but add
                            documentation to warn users against the dangers of exposing Clef’s API outside of their
                            own machine.

15 | Ethereum Clef Review                     Ethereum Foundation / NCC Group Confidential
Finding ECRecover Does Not Authenticate The Recovered Public Key

Risk Low Impact: Undetermined, Exploitability: Undetermined

Identifier NCC-EF-Clef-009

Category Cryptography

Location • signer/core/api.go

Impact Depending on the usage of this request, signatures could be tampered with in order to
             recover the wrong public key.

Description                The Clef API exposes an EcRecover method that allows to recover an Ethereum public-
                           key from a signed message. The method implements algorithm 4.1.6 (Public Key Recovery
                           Operation) from the Standards for Efficient Cryptography Group document on Elliptic Curve
                           Cryptography.10

                           As noted by the algorithm’s specification, several public keys can be recovered from a signa-
                           ture. This is due to the ECDSA signature algorithm removing some information from the r
                           value of a signature: only the x-coordinate is retained (2 solutions can be recovered for the
                           y-coordinate) and it is further reduced modulo the order of the elliptic curve. In the case of
                           Ethereum, secp256k1 is used which has a curve order slightly lower than the field modulus,
                           so indeed information is lost. The curve uses a cofactor of 1, so the number of possible
                           solutions to the algorithm are 2 × (1 + 1) = 4.

                           In order for the recovery algorithm to recover the correct solution, a v byte is added at the
                           end of every Ethereum signature. Its least significant bit contains the sign of the y-coordinate
                           of the r value and the rest of the bits contain information to re-compute the x-coordinate of
                           the r value.

                           Since these bits can be tampered with, an attacker could in some cases deceive the algorithm
                           by leading it to a wrong public key.

Recommendation In order to verify the recovered key, Clef needs to:

                           1. Verify that the key can be used to verify the signature passed in the request. This is step
                               1.6.2 of the SEC algorithm which is not implemented by Clef.

                           2. Match the recovered public key against an Ethereum address or another authentication
                               mechanism.

                           To protect against these attacks, the API of Clef needs to be changed to accept an extra
                           “authentication” argument.

Client Response            The ECRecover method was removed from Clef’s API: github.com/holiman/go-ethereum/co
                           mmit/cf3bf1724e58cc85ec87cb39a0aee0cb246c472e

                           10SEC 1: Elliptic Curve Cryptography version 2.0

16 | Ethereum Clef Review      Ethereum Foundation / NCC Group Confidential
Finding Outdated Dependencies

Risk Low Impact: Undetermined, Exploitability: Undetermined

Identifier NCC-EF-Clef-011

Category Patching

Location                   • signer/rules/deps/bignumber.js found at
                             – https://github.com/holiman/go-ethereum/blob/clefchanges_2/signer/rules/deps
                             – https://github.com/ethereum/go-ethereum/blob/master/signer/rules/deps

                           • vendor/vendor.json found at
                             – https://github.com/holiman/go-ethereum/blob/clefchanges_2/vendor
                             – https://github.com/ethereum/go-ethereum/blob/master/vendor

Impact Outdated dependencies may expose the application to publicly discovered vulnerabilities.

Description                Many of the largest breaches to date have relied on exploiting known vulnerabilities in out-
                           dated components. The Clef and Go-ethereum code repositories draw from many outdated
                           components, albeit without currently well-known vulnerabilities. The risk is proportional to
                           component functional and data sensitivity, development activity and quality, popularity, and
                           length of time between project dependency updates. The OWASP project lists this risk on the
                           Ten Most Critical Web Application Security Risks11 due to the widespread prevalence of this
                           issue.

                           The signer/rules/rules.go code utilizes signer/rules/deps/bindata.go to essentially
                           load the ‘bignumber.js’ library for arbitrary-precision decimal and non-decimal arithmetic.
                           The source of this library is signer/rules/deps/bignumber.js which is version 2.0.3. The
                           changelog for this project12 indicates that this version was released in February 2015, and
                           that the most recent version is 7.2.1. NCC Group is not aware of any publicly known vulnera-
                           bilities in this library.

                           The vendor/vendor.json file lists approximately 154 Golang dependencies with revision
                           timestamps ranging from early 2015 to August 2018. The majority of these are out of date
                           and can be updated. For example, there seven components sourced from a UPnP client
                           library for Go repository at https://github.com/huin/goupnp with a commit hash of 6795
                           07af18f3c7ba2bcc7905392ce23e148661c3 made on December 2016 which is 11 commits
                           out of date.

Recommendation             Update the project dependencies to the most recent and stable versions recommended for
                           production deployment. Include a regular review of dependency freshness as part of the
                           development process.

                           11https://www.owasp.org/images/7/72/OWASP_Top_10-2017_%28en%29.pdf.pdf
                           12https://github.com/MikeMcl/bignumber.js/blob/master/CHANGELOG.md

17 | Ethereum Clef Review      Ethereum Foundation / NCC Group Confidential
Finding Rules Dangerously Rely On Time And State

Risk Low Impact: Medium, Exploitability: Low

Identifier NCC-EF-Clef-012

Category Configuration

Location • cmd/clef/rules.md

Impact                     Attacks exist to alter Clef’s state and access to time. If successfully mounted, they would allow
                           an attacker to either revert the state used by Clef’s rule or alter the time as seen and used by
                           Clef. This could ultimately allow an attacker that has access to the Clef interface to remove
                           some limitations imposed by its rules.

Description                Clef allow users to write rules (in javascript) in order to automate handling of the requests
                           to Clef. Several examples are given in the documentation,13 the first one being a time rule
                           limiting how much ether can be sent over a window of 1 week. For this, the javascript run-time
                           environment relies on the time given by the system:

                           var windowstart = new Date().getTime() - window;

                           There exist different ways for attackers to affect the time of the device running Clef without
                           being root on the system:

                           1. If the CAP_SYS_TIME capability14 is set on the date program, any user can change the
                               time.

                           2. If the attacker has a privileged man-in-the-middle position in the network, she could attack
                               the NTP protocol15 to alter the device’s time.

                           Furthermore, to keep a state in between executions of the rules, Clef keeps an encrypted key-
                           value storage (jsStorage). Particular attacks might allow an attacker to alter this state and
                           remove some limitations (for example if a boolean has ben set to prevent further transactions,
                           reverting the state would allow transactions to flow again):

                           1. If the attacker has a physical access to the machine, she could re-set it to a previous
                               snapshot.

                           2. If the attacker has file permissions to the jsStorage, she could record changes and revert
                               the file to a previous point in time.

                           These attacks could allow an attacker to prevent certain rules from working correctly, or
                           worse, to drain wallets if the attacker has direct access to Clef’s API.

Recommendation             This finding highlights the fact that the security of the system running Clef is of utmost
                           importance. Different type of users should be given different recommendations, depending
                           on how much is at stake. Different threat models could be written, documenting what Clef
                           protects against and does not protect against. Ultimately, it is hard to defend against these
                           types of highly targeted attacks from powerful adversaries, and they should be out of the
                           threat model of Clef.

                           13cmd/clef/rules.md
                           14http://man7.org/linux/man-pages/man7/capabilities.7.html
                           15https://www.cs.bu.edu/~goldbe/NTPattack.html

18 | Ethereum Clef Review                         Ethereum Foundation / NCC Group Confidential
Finding Denial of Service Through Malformed Import Key

Risk Low Impact: Low, Exploitability: Low

Identifier NCC-EF-Clef-013

Category Data Validation

Location • accounts/keystore/keystore_passphrase.go

Impact                     A malicious attacker with access to the API or a privileged man-in-the-middle position could
                           craft malicious import requests or tamper with them in order to crash the application or alter
                           the keys imported without alerting the user.

Description                Clef’s API exposes an “Import” method allowing requests to import already existing accounts.
                           This import method accepts an encrypted key as argument, which must be formatted under
                           specific formats. Two formats are accepted by Clef: a version 1 and a version 3, which utilize
                           different encryption methods. Most of the code following the import of the key systematically
                           assumes that the argument passed by the request is trusted, which might be in practice since
                           rules cannot be written to handle this method: the user must manually accept an import
                           request. The following code paths all have issues:

                           Importing Private Keys. The Import flow ends up calling the crypto.ToECDSAUnsafe()
                           method which, as indicated, “blindly converts a binary blob to a private key. It should almost
                           never be used unless you are sure the input is valid and want to avoid hitting errors due to
                           bad origin encoding (0 prefixes cut off).”

                           JSON Parsing. Several fields from the passed JSON object are retrieved without previously
                           checking if they exist. The getKDFKey() function used to retrieve KDF parameters from the
                           request does not expect an empty map as cryptoJSON.KDFParams and will crash if given
                           one. Additionally, it expects integers as fields for the KDF object, even when given strings.

                           KDF parameters. A denial of service can be obtained by providing absurdly large param-
                           eters for the Scrypt Key Derivation Function, which will force the program to compute an
                           interminable cryptographic operation.

                           Authenticated Encryption. Before attempting the decryption of the imported key, the key-
                           store will verify the integrity of the ciphertext in order to detect any tampering from man-in-
                           the-middle attackers. This integrity check does not include the IV and is not done in constant
                           time. This could allow an attacker to tamper with the IV, making the user decrypt the wrong
                           private key, without any alert given by Clef (even though the “address” recovered is different
                           from the “address” field passed as argument in the request).

                           Decryption. Version 1 of the Importer will use AES-CBC to decrypt the received key, in
                           particular the low-level CryptBlocks function which takes a multiple of the blocksize as
                           argument. If not, the function will panic, as can be seen in .16

Reproduction Steps Run the following in the terminal with a Clef process exposing an RPC interface on local-
                              host:8550 and observe that the Clef application crashes.

                            curl -i -H "Content-Type: application/json" -X POST --data '{"jsonrpc":"2.0","me
                                  thod":"account_import","params":[{"version":"1","address":"string","id":"str
                                  ing","crypto":{"cipher":"","ciphertext":"","cipherparams":{"iv":""},"kdf":""
                                  ,"kdfparams":{},"mac":""}}],"id":67}' http://localhost:8550/

                           16crypto/cipher/cbc.go

19 | Ethereum Clef Review                            Ethereum Foundation / NCC Group Confidential
                            The following payloads also crash the application:

                                {"version":"1","address":"string","id":"string","crypto":{"cipher":"","ciphertex
                                      t":"","cipherparams":{"iv":""},"kdf":"","kdfparams":{"salt":"","dklen":"","n
                                      ":"","r":"","p":"","c":"","prf":""},"mac":""}}

                                {"version":"1","address":"string","id":"string","crypto":{"cipher":"","ciphertex
                                      t":"01","cipherparams":{"iv":""},"kdf":"pbkdf2","kdfparams":{"salt":"","dkle
                                      n":5,"n":5,"r":5,"p":5,"c":5,"prf":"hmac-sha256"},"mac":"32f2f344a0bdf0434df
                                      8d3c3fd2afd043c1a26b969bb7c448abd67a4af27ae03"}}

Recommendation Thoroughly document the fact that the Import API MUST be used with trusted and verified
                            inputs. In addition, address the issues underlined in this finding.

                            Furthermore, consider removing the Import method from the API of Clef.

20 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Finding Encrypted KeyStore Integrity Check Is Incomplete

Risk Low Impact: Low, Exploitability: Low

Identifier NCC-EF-Clef-014

Category Cryptography

Component keystore

Location • accounts/keystore/keystore_passphrase.go

Impact An attacker can tamper with a wallet backup without alerting the user, who would not realize
             the assault until trying to use the wallet key.

Description                The keystore package of Go-Ethereum has an exported EncryptKey() method capable of
                           storing wallets in an encrypted form. The encryption uses a key derived from a passphrase
                           known by the user. As a mean of integrity check, to ensure that a backup of an encrypted key
                           has not been tampered with, the keystore computes a message authentication code (MAC)
                           over the ciphertext as can be seen below:

                           // EncryptKey encrypts a key using the specified scrypt parameters into a json
                           // blob that can be decrypted later on.
                           func EncryptKey(key *Key, auth string, scryptN, scryptP int) ([]byte, error) {

                                        // ...

                                        derivedKey, err := scrypt.Key(authArray, salt, scryptN, scryptR, scrypt
                                 P, scryptDKLen)

                                        // ...
                                        iv := make([]byte, aes.BlockSize) // 16
                                        if _, err := io.ReadFull(rand.Reader, iv); err != nil {

                                                     panic("reading from crypto/rand failed: " + err.Error())
                                        }
                                        cipherText, err := aesCTRXOR(encryptKey, keyBytes, iv)
                                        // ...
                                        mac := crypto.Keccak256(derivedKey[16:32], cipherText)

                           This integrity check does not include the iv, important piece of the encryption/decryption
                            process, allowing attackers to tamper with it without having to modify the ciphertext. Since
                            the content encrypted is of high entropy, no strong attacks can be performed.

Recommendation Make use of an authenticated cipher like AES-GCM which compiles encryption with integrity
                            check as a single algorithm.

21 | Ethereum Clef Review                            Ethereum Foundation / NCC Group Confidential
Finding UI Mixes Extraneous and Approval-Specific Data

Risk Informational Impact: Undetermined, Exploitability: Undetermined

Identifier NCC-EF-Clef-006

Category Data Validation

Location signer/core/cliui.go

Impact An attacker could phish a user through the display of attacker controlled information in the
             Clef UI.

Description                When Clef receives a request through its exposed API, metadata is displayed to the user in
                           charge of handling it. This metadata includes a variety of fields unrelated to what is being
                           signed like IP address, user-agent, origin, etc. There are 6 calls to showMetadata() within
                           signer/core/cliui.go that drive this functionality. Some of these fields can be trivially
                           tampered with and might provide a false understanding as users could rely too heavily on
                           them instead of the important fields.

                           The following ‘malicious’ request (with the redacted JSON taken from Go code example com-
                           ments) will be accepted by Clef.

                           curl http://localhost:8550/ \
                              -i -H "Content-Type: application/json" \
                              -X POST --data '{...}' \
                              -A "indicates INVALID CHECKSUM IS EXPECTED" \
                              -H "Origin: NCC Group requires IMMEDIATE APPROVAL per direction of J Smith"

                           Clef will present the following information to the user.

                            --------- Transaction request-------------
                            to: 0x07a565b7ed7d7a678680a4c162885bedbb695fe0

                           WARNING: Invalid checksum on to-address!

                           from:  0x82A2A876D39022B3019932D30Cd9c97ad5616813 [chksum ok]

                           value: 16 wei

                           gas:   0x333 (819)

                           gasprice: 291 wei

                           nonce: 0x0 (0)

                           data:  0x4401a6e40000000000000000000000000000000000000000000000000000...012

                           Transaction validation:
                              * WARNING : Invalid checksum on to-address
                              * Info : safeSend(address: 0x0000000000000000000000000000000000000012)

                           Request context:
                                        127.0.0.1:40802 -> HTTP/1.1 -> localhost:8550

                                        User-Agent: indicates INVALID CHECKSUM IS EXPECTED
                                        Origin: NCC Group requires IMMEDIATE APPROVAL per direction of J Smith
                           -------------------------------------------
                           Approve? [y/N]:
                           >

                           As currently presented, the metadata provides little benefit to legitimate requests but may
                           facilitate illegitimate requests. A naive user may consider the extraneous request data as

22 | Ethereum Clef Review                                            Ethereum Foundation / NCC Group Confidential
                           superseding the true warning above and mistakenly approve this transaction.

Recommendation             Do not present request metadata alongside approval-specific data without clear delineation
                           and warnings. Either clearly label the categories presented and warn that request data
                           cannot be relied upon, or simply remove all request data.

Client Response            An additional message was added before displaying metadata provided by the external caller
                           of the API: github.com/holiman/go-ethereum/commit/c6d7644e5a5bd0fe23c7f060a390112
                           115515cab

23 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Appendix A: Finding Field Definitions

The following sections describe the risk rating and category assigned to issues NCC Group identified.

Risk Scale

NCC Group uses a composite risk score that takes into account the severity of the risk, application’s exposure and
user population, technical difficulty of exploitation, and other factors. The risk rating is NCC Group’s recommended
prioritization for addressing findings. Every organization has a different risk sensitivity, so to some extent these
recommendations are more relative than absolute guidelines.

Overall Risk
Overall risk reflects NCC Group’s estimation of the risk that a finding poses to the target system or systems. It takes
into account the impact of the finding, the difficulty of exploitation, and any other relevant factors.

          Critical Implies an immediate, easily accessible threat of total compromise.
             High Implies an immediate threat of system compromise, or an easily accessible threat of large-scale
                      breach.

        Medium A difficult to exploit threat of large-scale breach, or easy compromise of a small portion of the
                      application.

             Low Implies a relatively minor threat to the application.
Informational No immediate threat to the application. May provide suggestions for application improvement,

                      functional issues with the application, or conditions that could later lead to an exploitable finding.

Impact
Impact reflects the effects that successful exploitation upon the target system or systems. It takes into account
potential losses of confidentiality, integrity and availability, as well as potential reputational losses.

             High Attackers can read or modify all data in a system, execute arbitrary code on the system, or escalate
                      their privileges to superuser level.

        Medium Attackers can read or modify some unauthorized data on a system, deny access to that system, or
                      gain significant internal technical information.

             Low Attackers can gain small amounts of unauthorized information or slightly degrade system
                      performance. May have a negative public perception of security.

Exploitability
Exploitability reflects the ease with which attackers may exploit a finding. It takes into account the level of access
required, availability of exploitation information, requirements relating to social engineering, race conditions, brute
forcing, etc, and other impediments to exploitation.

             High Attackers can unilaterally exploit the finding without special permissions or significant roadblocks.
        Medium Attackers would need to leverage a third party, gain non-public information, exploit a race condition,

                      already have privileged access, or otherwise overcome moderate hurdles in order to exploit the
                      finding.
             Low Exploitation requires implausible social engineering, a difficult race condition, guessing difficult-to-
                      guess data, or is otherwise unlikely.

24 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Category

NCC Group categorizes findings based on the security area to which those findings belong. This can help organizations
identify gaps in secure development, deployment, patching, etc.

           Access Controls Related to authorization of users, and assessment of rights.
   Auditing and Logging Related to auditing of actions, or logging of problems.

            Authentication Related to the identification of users.
             Configuration Related to security configurations of servers, devices, or software.
              Cryptography Related to mathematical protections for data.
             Data Exposure Related to unintended exposure of sensitive information.
           Data Validation Related to improper reliance on the structure or values of data.
          Denial of Service Related to causing system failure.
           Error Reporting Related to the reporting of error conditions in a secure fashion.

                    Patching Related to keeping software up to date.
    Session Management Related to the identification of authenticated users.

                      Timing Related to race conditions, locking, or order of operations.

25 | Ethereum Clef Review  Ethereum Foundation / NCC Group Confidential
Appendix B: Project Contacts

The team from NCC Group has the following primary members:
• David Wong — Consultant

  david.wong@nccgroup.trust
• Eric Schorn — Consultant

  Eric.Schorn@nccgroup.trust

The team from Ethereum Foundation has the following primary member:
• Martin Swende — Ethereum Foundation

  martin.swende@ethereum.org

26 | Ethereum Clef Review                                            Ethereum Foundation / NCC Group Confidential

